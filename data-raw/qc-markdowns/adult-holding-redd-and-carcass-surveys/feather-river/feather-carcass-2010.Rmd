---
title: "Feather Carcass QC 2010"
author: "Jonathan Fernandez"
date: "06/17/2022"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, fig.width=15, fig.height=10)

library(tidyverse)
library(lubridate)
library(googleCloudStorageR)
library(ggplot2)
library(scales)
library(readxl)
library(janitor)
library(hms) #?as_hms()
library(RODBC)
library(wesanderson)
library(knitr)

```

# Feather River Carcass Data

## Description of Monitoring Data

**Timeframe:** 

**Video Season:** 

**Completeness of Record throughout timeframe:** 

**Sampling Location:**

**Data Contact:** 

Any additional info?

## Access Cloud Data

```{r, eval=FALSE}
# Run Sys.setenv() to specify GCS_AUTH_FILE and GCS_DEFAULT_BUCKET before running 
# getwd() to see how to specify paths 
# Open object from google cloud storage
# Set your authentication using gcs_auth
Sys.setenv("GCS_AUTH_FILE" = "C:/Users/InigoPeng/Projects/jpe/JPE-datasets/config.json")
Sys.setenv("GCS_DEFAULT_BUCKET" = "jpe-dev-bucket")

gcs_auth(json_file = Sys.getenv("GCS_AUTH_FILE"))
# Set global bucket 
gcs_global_bucket(bucket = Sys.getenv("GCS_DEFAULT_BUCKET"))

# git data and save as xlsx
```

Read in data from google cloud, glimpse raw data and domain description sheet: 

```{r}
# knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

# Google Cloud Set up
# Sys.setenv("GCS_AUTH_FILE" = "config.json")
# Sys.setenv("GCS_DEFAULT_BUCKET" = "jpe-dev-bucket")
# 
gcs_get_object(object_name = "adult-holding-redd-and-carcass-surveys/feather-river/data-raw/carcass/ChopChannelTBL1.xlsx",
               bucket = gcs_get_global_bucket(),
               saveToDisk = "ChopChannelTBL1.xlsx",
               overwrite = TRUE)

gcs_get_object(object_name = "adult-holding-redd-and-carcass-surveys/feather-river/data-raw/carcass/ChopHeaderTBL.xlsx",
               bucket = gcs_get_global_bucket(),
               saveToDisk = "ChopHeaderTBL.xlsx",
               overwrite = TRUE)

gcs_get_object(object_name = "adult-holding-redd-and-carcass-surveys/feather-river/data-raw/carcass/ChopRecovTBL.xlsx",
               bucket = gcs_get_global_bucket(),
               saveToDisk = "ChopRecovTBL.xlsx",
               overwrite = TRUE)

# Read Data
# this is our main data collection table
ChopChannel_raw <- read_excel("ChopChannelTBL1.xlsx") %>% 
  rename("ID" = HeaderID) %>% 
  glimpse()

# This is a survey info and covariate table
ChopHeader_raw <- read_excel("ChopHeaderTBL.xlsx") %>% 
  rename("ID" = headerID) %>% 
  glimpse()

# this is recovery data to be used to determine how many carcasses are being captured
# We will likely retain this information in another table for clarity
ChopRecov_raw <-read_excel("ChopRecovTBL.xlsx") %>% 
  glimpse()

# thoughts on how to link chopchannel with choprecovery: don't need to do this, for future reference
# use chopchannel to count number tagged per day
# link to chopheader by ID to get tag color
# link to chopreocv by recovid (= ID) to get the date recovered
# can summarize the number of each color recovered by date and link to the date applied
```

```{r}
# TODO: Attempt, but not needed
# from ashley: this is code to read in tables from Access. Have you figured out 
# how to get this to work on your machine?

# library(Hmisc) 
# 
# # List of all available tables
# mdb.get("CAMP_Escapement_20210412.mdb")
# 
# # Code to read in the CatchRaw table
# carcasschops <- mdb.get("CAMP_DB_for_FlowWest/CAMP_Escapement_20210412.mdb", tables = "CarcassChops")
# 

```

## Data transformations

```{r}
# 1. we need to link chopheader and chopchannel to get the dates and tag color applied
# 2. we need to link chopheader and choprecov to get the dates

#1. chopchannel table (with dates and tag color)
chop_channel_join <- full_join(ChopHeader_raw %>% 
                                 select(ID, TagCol, Date, Time),
                               ChopChannel_raw) %>% 
  clean_names()

# 2. choprecovery table (with dates)

chop_recovery_join <- full_join(ChopHeader_raw %>% 
                                  select(ID, Date, Time),
                                ChopRecov_raw %>% 
                                  rename(ID = RecovID))  %>% 
  clean_names()

chop_header <- ChopHeader_raw %>% 
  clean_names()
```

### Counts

The `chop_channel` table contains carcass counts by sex and chop/tagged

### Recovery

The `chop_recovery` table contains recovered carcass counts by color

### Survey

The `chop_header` table contains survey metadata and covariates


## Explore Numeric Variables: {.tabset}

```{r}
# Filter clean data to show only numeric variables 
chop_channel_join %>% 
  select_if(is.numeric) %>%
  colnames()
```
### Variable: `id`, `chan_id`, `sect`, `min`

```{r}
summary(chop_channel_join$id)
```
```{r}
summary(chop_channel_join$chan_id)
```
```{r}
summary(chop_channel_join$sect)
```

```{r}
summary(chop_channel_join$min)
```
### Variable: `female_chop`, `male_chop`,`unknown_chop`

**Numeric Summary of `female_chop`, `male_chop`,`unknown_chops` over Period of Record**

```{r}
summary(chop_channel_join$female_chop)
```

```{r}
summary(chop_channel_join$male_chop)
```

```{r}
summary(chop_channel_join$unknown_chops)
```

**NA and Unknown Values**
Provide a stat on NA or unknown values.

```{r}
round(sum(is.na(chop_channel_join$male_chop))/nrow(chop_channel_join), 3) * 100
round(sum(is.na(chop_channel_join$female_chop))/nrow(chop_channel_join), 3) * 100
round(sum(is.na(chop_channel_join$unknown_chops))/nrow(chop_channel_join), 3) * 100
```
* `r round(sum(is.na(chop_channel_join$male_chop))/nrow(chop_channel_join), 3) * 100` % of values in the `male_chop` column are NA.
* `r round(sum(is.na(chop_channel_join$female_chop))/nrow(chop_channel_join), 3) * 100` % of values in the `female_chop` column are NA.
* `r round(sum(is.na(chop_channel_join$unknown_chops))/nrow(chop_channel_join), 3) * 100` % of values in the `unknown_chops` column are NA.

**Plotting female_chop over Period of Record**

### from ashley: for the dotplots, lets put the date on the x-axis i think it would be easier to read

```{r}
# Make whatever plot is appropriate 
filter(chop_channel_join) %>% 
  ggplot(aes(x = date, y = female_chop)) +
  geom_point(size = 1.4, alpha = .5, color = "blue") + 
  labs(x = "Date", 
       y = "Female Chop") +
  theme_minimal() + 
  theme(text = element_text(size = 15)) 
```


**Plotting male_chop over Period of Record**
```{r}
# Make whatever plot is appropriate 
filter(chop_channel_join) %>% 
  ggplot(aes(x = date, y = male_chop)) +
  geom_point(size = 1.4, alpha = .5, color = "red") + 
  labs(x = "Date", 
       y = "Male Chop") +
  theme_minimal() + 
  theme(text = element_text(size = 15)) 
```

**Plotting unknown_chops over Period of Record**
```{r}
# Make whatever plot is appropriate 
filter(chop_channel_join) %>% 
  ggplot(aes(x = date, y = unknown_chops)) +
  geom_point(size = 1.4, alpha = .5, color = "black") + 
  labs(x = "Date", 
       y = "Unknown Chops") +
  theme_minimal() + 
  theme(text = element_text(size = 15)) 
```

**Plotting Total chops over Period of Record**

```{r}
chop_channel_join %>% glimpse()

# Percentage by Gender of Daily Chops
# Address NA values for chops
total_chops <- chop_channel_join%>%
  mutate(male_chop = ifelse(is.na(male_chop), 0, male_chop), # fill na
         female_chop = ifelse(is.na(female_chop), 0, female_chop),
         unknown_chop = ifelse(is.na(unknown_chops), 0, unknown_chops),
         total_chops = unknown_chops + male_chop + female_chop) %>% 
  select(date, male_chop, female_chop, unknown_chops, total_chops)

# Case check: checking for duplicates
total_chops_test <- total_chops %>% # get total chops
  filter(date == as_date("2010-09-07"))

# Check if NAs introduced in creating total chop columns
nrow(total_chops_test) == (sum(total_chops_test$total_chops == (total_chops_test$male_chop + total_chops_test$female_chop + total_chops_test$unknown_chops)))

# total number of chops for the day
total_chops_summary <- total_chops %>%
  group_by(date) %>%
  summarise(total_chops = sum(total_chops, na.rm = T),
            male_chops = sum(male_chop, na.rm = T),
            female_chops = sum(female_chop, na.rm = T),
            unknown_chops = sum(unknown_chops, na.rm = T))

# Look into NA in date. Why are there date gaps?
# Potential issue: Reading in excel can introduce NA (not case here)
# Potential issue: Joins introduces NA (the case)
# Potential issue: Could just be missing (not missing, but just periodically collected 2-3 weekdays of the week no specific day)

# check if NAs are introduced in merge
A = left_join(ChopChannel_raw, ChopHeader_raw, by = "ID")$ChanID
B = ChopRecov_raw$ChanID
sum(B %in% A) # they are
# yes I noticed that. there are some IDs in the chop_channel table that are not in the chop_header table. there are A LOT of IDs in the recovery table that are not in header table. at this point i would assume this is a data entry issue and we can leave as is but clearly document. this is something we may learn more about and then be able to fix
```


```{r}
# # Check why some plots are above 100%
# proportion_irregularities <- total_chops_summary %>%
#   pivot_longer(cols = c(male_chops, female_chops, unknown_chops), names_to = "sex", values_to = "count") %>%
#   mutate(proportions = (count / total_chops)) %>% 
#   group_by(date) %>%
#   summarise(date = date,
#             proportion_sum = sum(proportions)) %>% 
#   mutate(need_to_check = ifelse((proportion_sum > 1), TRUE, FALSE)) %>% 
#   filter(need_to_check == TRUE)
# 
# # Explore the irregularities
# proportion_irregularities_date = proportion_irregularities$date
# proportion_irregularities_date_index = total_chops_summary$date %in% proportion_irregularities_date
# total_chops_summary %>% 
#   filter(proportion_irregularities_date_index) %>% 
#   mutate(proportion = (male_chops + female_chops + unknown_chops) / (total_chops))
# # It is result of significant figure rounding error

# plot
total_chops_summary %>% 
  pivot_longer(cols = c(male_chops, female_chops, unknown_chops), names_to = "sex", values_to = "count") %>% 
  mutate(proportions = (count / total_chops)) %>% 
  ggplot(aes(x = date, y = proportions, fill = sex)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = c("Blue","Red", "Black"), 
                    name = "Sex", 
                    labels = c("Female", "Male", "Unknown")) +
  theme_minimal() + 
  labs(y = "Proportion", x = "Date") +
  scale_fill_manual(values = wes_palette("Moonrise2"))

```
This plot shows the gender proportion of chops for each day over the the period of 2010-09-07 to 2010-12-22. The data gaps that we see are a result of the data collection process in which the data was collected 2-4 days each week (with no specific period day of week) over the 4 month period. We can also observe some of the proportions exceed 1 which was a result of rounding/significant figure sums, so these can be ignored. Also, it was interesting to see the unknown sex account for most of the chops towards the latter periods.

### Variable: `female_tag`, `male_tag`,`unknown_tag`

**Numeric Summary of `female_tag`, `male_tag`,`unknown_tag` over Period of Record**

```{r}
summary(chop_channel_join$male_tag)
```

```{r}
summary(chop_channel_join$female_tag)
```

```{r}
summary(chop_channel_join$unknown_tags)
```

**NA and Unknown Values**
Provide a stat on NA or unknown values

```{r}
round(sum(is.na(chop_channel_join$male_tag))/nrow(chop_channel_join), 3) * 100
round(sum(is.na(chop_channel_join$female_tag))/nrow(chop_channel_join), 3) * 100
round(sum(is.na(chop_channel_join$unknown_tags))/nrow(chop_channel_join), 3) * 100
```

* `r round(sum(is.na(chop_channel_join$male_chop))/nrow(chop_channel_join), 3) * 100` % of values in the `male_chop` column are NA.
* `r round(sum(is.na(chop_channel_join$female_chop))/nrow(chop_channel_join), 3) * 100` % of values in the `female_tag` column are NA.
  * `r round(sum(is.na(chop_channel_join$unknown_chops))/nrow(chop_channel_join), 3) * 100` % of values in the `unknown_tags` column are NA.

**Plotting female_tag over Period of Record**
```{r}
# Make whatever plot is appropriate 
filter(chop_channel_join) %>% 
  ggplot(aes(x = date, y = female_tag)) +
  geom_point(size = 1.4, alpha = .5, color = "blue") + 
  labs(x = "Date", 
       y = "Female Tag") +
  theme_minimal() + 
  theme(text = element_text(size = 15)) 
```

**Plotting male_tag over Period of Record**

```{r}
# Make whatever plot is appropriate 
filter(chop_channel_join) %>% 
  ggplot(aes(x = date, y = male_tag)) +
  geom_point(size = 1.4, alpha = .5, color = "red") + 
  labs(x = "Date", 
       y = "Male Tag") +
  theme_minimal() + 
  theme(text = element_text(size = 15)) 
```

**Plotting unknown_tags over Period of Record**
```{r}
# Make whatever plot is appropriate 
filter(chop_channel_join) %>% 
  ggplot(aes(x = date, y = unknown_tags)) +
  geom_point(size = 1.4, alpha = .5, color = "black") + 
  labs(x = "Date", 
       y = "Unknown Tags") +
  theme_minimal() + 
  theme(text = element_text(size = 15)) 
```

**Plotting Total Tags over Period of Record**
```{r}
# Percentage by Gender of Daily Chops
# Address NA values for chops
total_tags <- chop_channel_join %>%
  mutate(male_tag = ifelse(is.na(male_tag), 0, male_tag), # fill na
         female_tag = ifelse(is.na(female_tag), 0, female_tag),
         unknown_tags = ifelse(is.na(unknown_tags), 0, unknown_tags),
         total_tags = unknown_tags + male_tag + female_tag) %>% 
  select(date, male_tag, female_tag, unknown_tags, total_tags)

# total number of chops for the day
total_tags_summary <- total_tags %>%
  group_by(date) %>%
  summarise(total_tags = sum(total_tags, na.rm = T),
            male_tags = sum(male_tag, na.rm = T),
            female_tags = sum(female_tag, na.rm = T),
            unknown_tags = sum(unknown_tags, na.rm = T))

# Plot to identify proportions by sex for each day
total_tags_summary %>% 
  pivot_longer(cols = c(male_tags, female_tags, unknown_tags), names_to = "sex", values_to = "count") %>% 
  mutate(proportions = (count / total_tags)) %>% 
  ggplot(aes(x = date, y = proportions, fill = sex)) +
  geom_bar(stat = "identity", position = "stack")

# Make Graph Prettier
total_tags_summary %>% 
  pivot_longer(cols = c(male_tags, female_tags, unknown_tags), names_to = "sex", values_to = "count") %>% 
  mutate(proportions = (count / total_tags)) %>% 
  ggplot(aes(x = date, y = proportions, fill = sex)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = c("Blue","Red", "Black"), 
                    name = "Sex", 
                    labels = c("Female", "Male", "Unknown")) +
  theme_minimal() + 
  labs(y = "Proportion", x = "Date") +
  scale_fill_manual(values = wes_palette("Moonrise2"))

#check why period of graph is cut short
# cleaner_chopTBL %>% filter(date > "2010-11-01") %>% 
#   select(date, male_tag, female_tag, unknown_tags)
# 
# #check why there is such a big gap
# cleaner_chopTBL %>% filter(date < "2010-10-01") %>% 
#   select(date, male_tag, female_tag, unknown_tags)
```
This plot shows the gender proportion of tags for each day over the the period of 2010-09-07 to 2010-12-22. The period appears to be shorter, because the tags recorded during the december period are 0. The data gaps that we see are a result of the data collection process in which the data was collected 2-4 days each week (with no specific period day of week) over the 4 month period. In comparison to the chops, we can see the tags tend to be more identifiable in terms of gender. The observed data gap is a result of reporting to be 0, which we would not expect the case to be. I am thinking they may have had not collected data during this period and the values of 0 might be an indication of missing data. 

# from ashley: also looks like there was a tag in early september and no chops that early

**Comparing tags and chops**

```{r}
# from ashley: please improve on this plot I got started, make it look better, describe it, double check that the numbers make sense
total_carcass <- full_join(total_chops_summary, total_tags_summary) %>% 
  select(date, total_chops, total_tags) %>% 
  pivot_longer(c(total_chops, total_tags), names_to = "mark")

full_join(total_chops_summary, total_tags_summary) %>% 
  select(date, total_chops, total_tags) %>% 
  pivot_longer(c(total_chops, total_tags), names_to = "mark")

ggplot(total_carcass, aes(x = date, y = value, fill = mark)) +
  geom_col() +
  theme_minimal() +
  scale_fill_manual(values = wes_palette("Moonrise2"))

```

Tags appear to be less commonly applied compared to chops.

```{r}
# Filter clean data to show only numeric variables 
chop_recovery_join %>% 
  select_if(is.numeric) %>%
  colnames()
```

```{r}
summary(chop_recovery_join$id)
```

```{r}
summary(chop_recovery_join$chan_id)
```

```{r}
summary(chop_recovery_join$recov_count)
```

```{r}
# Filter clean data to show only numeric variables
# week_num is a derivitive variable and doesn't need to be summarized. i think we can remove it
chop_header %>% 
  select_if(is.numeric) %>%
  colnames()
```

```{r}
summary(chop_header$id)
```

```{r}
summary(chop_header$tag_col)
```

## Explore Categorical variables: {.tabset}

```{r}
# Filter clean data to show only categorical variables
chop_channel_join %>% 
  select_if(is.character) %>%
  colnames()
```

## Clean data

Fix inconsistencies with spelling, capitalization, and dates

```{r}
chop_channel_cleaner <- chop_channel_join %>% 
  mutate_if(is.character, str_to_lower) %>% 
  mutate(time = as_hms(time),
         datetime = ifelse((is.na(date) | is.na(time)), NA, ymd_hms(paste(date, time)))) %>% 
  select(-c(date, time))

chop_channel_cleaner
```

```{r}
chop_recovery_cleaner <- chop_recovery_join %>% 
  mutate_if(is.character, str_to_lower) %>% 
  mutate(time = as_hms(time),
         datetime = ymd_hms(paste(date, time))) %>% 
  select(-c(date, time))

chop_recovery_cleaner
```

```{r}
chop_header_cleaner <- chop_header %>% 
  mutate_if(is.character, str_to_lower) %>% 
  mutate(time = as_hms(time),
         datetime = ymd_hms(paste(date, time)),
         crew = str_replace(crew, " ", ",")) %>% 
  select(-c(date, time, week_num))
chop_header_cleaner
```

## Data Dictionaries

### Channel

```{r}
percent_na <- chop_channel_cleaner %>%
  summarise_all(list(name = ~sum(is.na(.))/length(.))) %>%
  pivot_longer(cols = everything())


counts_data_dictionary <- tibble(variables = colnames(chop_channel_cleaner),
                          description = c("ID",
                                          "Color of tag applied to carcass",
                                          "Date and time of survey",
                                          "Channel ID",
                                          "Sect", 
                                          "Chan", 
                                          "Min", 
                                          "Carcass that were chopped and sex was unknown",
                                          "Carcass that were tagged and sex was unknown",
                                          "Carcass that were chopped and male",
                                          "Carcass that were chopped and female",
                                          "Carcass that were tagged and female",
                                          "Carcass that were tagged and male"),
                          percent_na = round(percent_na$value*100))

kable(counts_data_dictionary)
```

### Recovery

```{r}
percent_na <- chop_recovery_cleaner %>%
  summarise_all(list(name = ~sum(is.na(.))/length(.))) %>%
  pivot_longer(cols = everything())


recovery_data_dictionary <- tibble(variables = colnames(chop_recovery_cleaner),
                          description = c("ID",
                                          "Color of tag recovered from carcass",
                                          "Count of recovery",
                                          "Channel ID",
                                          "Datetime"),
                          percent_na = round(percent_na$value*100))

kable(recovery_data_dictionary)
```

### Survey

```{r}
# 
# percent_na <- chop_header_cleaner %>%
#   summarise_all(list(name = ~sum(is.na(.))/length(.))) %>%
#   pivot_longer(cols = everything())
# 
# counts_data_dictionary <- tibble(variables = colnames(chop_header_cleaner),
#                           description = c("ID",
#                                           "Color of tag of carcass",
#                                           "Crew memeber initials that collected",
#                                           "Individual of crew member who recorded",
#                                           "Weather", 
#                                           "Comments", 
#                                           "Datetime",
#                           percent_na = round(percent_na$value*100)))
# 
# kable(counts_data_dictionary)
```

## Save cleaned data back to google cloud (TBA)

```{r}
# Name file [watershed]_[data type].csv
```
