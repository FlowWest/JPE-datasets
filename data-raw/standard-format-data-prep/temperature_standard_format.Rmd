---
title: "Combine Temperature Data"
output: 
  html_document:
  theme: flatly
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include=FALSE}
library(tidyverse)
library(googleCloudStorageR)
library(CDECRetrieve)
library(lubridate)
library(hms)
library(weathermetrics) 
library(forecast)
library(zoo)

root.dir <- rprojroot::find_rstudio_root_file()
knitr::opts_knit$set(root.dir)
```

FlowWest aggregated environmental data for temperature data from all 
monitoring programs:

-   Feather River (source: CDEC & DWR loggers)
-   Battle Creek (source: USFWS loggers)
-   Butte Creek (source: CDEC)
-   Clear Creek (source: USFWS loggers)
-   Deer Creek (source: CDEC)
-   Mill Creek (source: CDEC)
-   Sacramento River (source: USGS & CDFW loggers)
-   Yuba River (source: CDEC & DWR loggers)

### Rationale for Data Sources:

The following decision hierarchy was used to determine which datasets
were used in the final temperature data aggregation:

1.  Is there publicly available data available through USGS or CDEC?
    This data can easily be built into a data pipeline because it's
    available through a query and publicly available. The data is also
    QC'd and available at precise temporal scales like hourly.
2.  If no, is there data available through gages operated by US Fish and Wildlife?
3.  If no, is there RST temperature monitoring data available?
4.  If there are no other data available or if there are extensive data gaps, build a regression model with another similar stream in order to fill in data gaps.

## Standard format for Temperature Data

Data dictionary for standard format:

(B - Battle Creek, Bu - Butte Creek, C - Clear Creek, F - Feather River,
D - Deer Creek, F - Feather River, M - Mill Creek, S- Sacramento River,
Y - Yuba River)

| column name       | stream collects   | definition                                          |
|:-----------------|:-------------------|:---------------------------------|
| date              | B, Bu, C, D, M, F, S | date that measurement occurs                        |
| stream            | B, Bu, C, D, M, F, S | unique stream name associated with temperature data |
| site              | B, Bu, C, D, M, F, S | unique site identifier where measurement occurs     |
| subsite           | B, Bu, C, D, M, F, S | unique subsite identifer that data can be applied to |
| gage_agency       | B, Bu, C, D, M, F, S | agency that collects data  |
| gage_numger       | B, Bu, C, D, M, F, S | unique gage identifier |
| value             | B, Bu, C, D, M, F, S | Temperature value in degress Celsius                |
| statistics        | B, Bu, C, D, M, F | mean, min, max summary statistic                    |

# Pull in data and format {.tabset}

Initial data exploration was done `r here::here("data-raw", "qc-markdowns", "temperature_data_prep.Rmd")`

### All RST Environmental Data 

```{r, include = F}
# source file where gage data is pulled, need to run this file first
# source(knitr::purl(here::here("data-raw", "qc-markdowns", "temperature_data_prep.Rmd"), quiet=TRUE))

# set up GCS
gcs_auth(json_file = Sys.getenv("GCS_AUTH_FILE"))
gcs_global_bucket(bucket = Sys.getenv("GCS_DEFAULT_BUCKET"))

gcs_get_object(object_name = "standard-format-data/standard_rst_catch.csv",
               bucket = gcs_get_global_bucket(),
               saveToDisk = "data/rst/standard_catch.csv",
               overwrite = TRUE)
catch <- read_csv("data/rst/standard_catch.csv")

gcs_get_object(object_name = "standard-format-data/standard_RST_environmental.csv",
               bucket = gcs_get_global_bucket(),
               saveToDisk = "data/rst/standard_environmental.csv",
               overwrite = TRUE)
rst_enviro <- read_csv("data/rst/standard_environmental.csv")
```

## Battle Creek

-   One site from the Fish and Wildlife Service provides data from
    `2003-01-07` to `2021-02-2021`
-   TODO reach out to Stream Team and update with data through 2023

```{r}
ubc_temp_raw <- readRDS(here::here("data-raw", "standard-format-data-prep","temp_data", "battle_temp.rds"))

battle_format <- ubc_temp_raw %>% 
  mutate(date = as_date(date)) |> 
  group_by(date) |> 
  summarise(mean_temp_degC = mean(temp_degC, na.rm = T),
            max_temp_degC = max(temp_degC, na.rm = T),
            min_temp_degC = min(temp_degC, na.rm = T)) %>% 
  mutate(stream = "battle creek", 
         site = "ubc",
         subsite = "ubc",
         date = as.Date(date),
         gage_agency = "USFWS",
         gage_number = "logger")

summary(battle_format)

battle_format %>% ggplot() + 
  geom_line(aes(x = date, y = mean_temp_degC, color = site)) + 
  # geom_point(aes(x = date, y = mean_temp_degC), size = .001) +
  theme_minimal()
```

## Butte Creek

-   The CDEC gage `BCK` was used for sites `adams dam` and `okie dam` from `1998-09-16` to `2022-06-30`. USGS data was used to establish thresholds to identify min and max temperatures and datapoints that were outside this range were considered outliers. Outliers were interpolated using linear approximation methods.

```{r}
# source CDEC
butte <- read_rds(here::here("data-raw", "standard-format-data-prep","temp_data", "butte_temp.rds"))
butte_format <- butte %>%
  mutate(stream = "butte creek",
         gage_agency = "CDEC",
         gage_number = "BCK")

butte_sites <- filter(catch, stream == "butte creek") |> 
  select(stream, site, subsite) |> 
  distinct()

butte_format_all <- full_join(butte_format, butte_sites)

summary(butte_format_all$date)

butte_format_all %>% ggplot() + 
  geom_line(aes(x = date, y = mean_temp_degC, color = site)) + 
  # geom_point(aes(x = date, y = mean_temp_degC), size = .001) +
  theme_minimal() 

filter(catch, stream == "butte creek") |> distinct(site, subsite)
```

## Clear Creek

-   Clear Creek data was aggregated from US Fish Wildlife Service's site
    `lcc` from `2001-02-16` to `2021-12-31` and `ucc` from `2003-01-07` to `2021-02-01`

```{r}
ucc_temp_raw <- readRDS(here::here("data-raw", "standard-format-data-prep","temp_data", "upper_clear_temp.rds"))

ucc_temp <- ubc_temp_raw %>% 
  mutate(stream = "clear creek", 
         site = "ucc",
         subsite = "ucc",
         date = as.Date(date),
         gage_agency = "USFWS",
         gage_number = "logger")

lcc_temp_raw <- readRDS(here::here("data-raw", "standard-format-data-prep","temp_data", "lower_clear_temp.rds"))

lcc_temp <- lcc_temp_raw  %>% 
  mutate(stream = "clear creek", 
         site = "lcc",
         subsite = "lcc",
         date = as.Date(date),
         gage_agency = "USFWS",
         gage_number = "logger")

clear_format <- bind_rows(lcc_temp, ucc_temp) %>% 
  mutate(date = as_date(date)) |> 
  group_by(date, stream, site, subsite, gage_agency, gage_number) %>%
  summarise(mean_temp_degC = mean(temp_degC, na.rm = T),
            max_temp_degC = max(temp_degC, na.rm = T),
            min_temp_degC = min(temp_degC, na.rm = T)) 

summary(clear_format$date)

clear_format %>% ggplot() + 
  geom_line(aes(x = date, y = mean_temp_degC, color = site)) + 
  # geom_point(aes(x = date, y = mean_temp_degC), size = .001) +
  theme_minimal()

filter(catch, stream == "clear creek") |> distinct(site, subsite)
```

## Deer Creek

-   Deer Creek data was aggregated from CDEC's site `DCV` from
    `1998-10-01` to `2022-07-13`. USGS data was used to establish thresholds to identify min and max temperatures and datapoints that were outside this range were considered outliers. Outliers were interpolated using linear approximation methods.

```{r}
# source 
deer <- read_rds(here::here("data-raw", "standard-format-data-prep","temp_data", "deer_temp.rds")) %>% glimpse
deer_format <- deer %>%
  mutate(stream = "deer creek",
         site = stream,
         subsite = site,
         gage_agency = "CDEC",
         gage_number = "DCV")

summary(deer_format$date)

deer_format %>% ggplot() + 
  geom_line(aes(x = date, y = mean_temp_degC), color = "gray") + 
  theme_minimal()

deer_format %>% ggplot() + 
  geom_line(aes(x = date, y = max_temp_degC), color = "gray") + 
  theme_minimal()
```

## Feather River

Two stations:
* GRL (2003-03-05 to 2007-06-01 H; 2020-01-04 to present E): located after Thermalito Afterbay
* FRA (2002-01-01 to present): located between Lake Oroville and Thermalito Afterbay


- GRL will represent the High Flow Channel (HFC) and FRA will represent the Low Flow Channel (LFC). Data collected at the RST will be appended to these datasets to provide a more complete dataset. Eye Riffle site will be used to represent all LFC sites and Herringer Riffle will be used to represent all HFC sites as these datasets are the most extensive. 
- In order to fill remaining data gaps a linear regression model was built to determine the relationship between Feather River temperature Butte Creek temperature (Butte Creek temperature is an extensive dataset). This model was then used to predict temperatures for dates where there were data gaps.

#### Gage data

```{r}

hfc_feather <- readRDS(here::here("data-raw", "standard-format-data-prep","temp_data", "feather_hfc_temp.rds"))

lfc_feather <- readRDS(here::here("data-raw", "standard-format-data-prep","temp_data", "feather_lfc_temp.rds"))

feather_sites <- catch |> 
  filter(stream == "feather river") |> 
  distinct(stream, site, site_group, subsite)

feather_hfc_sites <- filter(feather_sites, site_group == "feather river hfc")
feather_lfc_sites <- filter(feather_sites, site_group == "feather river lfc")

feather_hfc_format <- hfc_feather %>% 
  rename(mean = mean_temp_degC,
         min = min_temp_degC,
         max = max_temp_degC) |> 
  pivot_longer(cols = mean:min, names_to = "statistic", values_to = "value") |> 
  mutate(stream = "feather river",
         gage_agency = "CDEC",
         gage_number = "GRL",
         site_group = "feather river hfc")

feather_hfc_format %>% ggplot() + 
  geom_line(aes(x = date, y = value, color = statistic)) + 
  # geom_point(aes(x = date, y = mean_temp_degC), size = .001) +
  theme_minimal() 

feather_lfc_format <- lfc_feather %>% 
  rename(mean = mean_temp_degC,
         min = min_temp_degC,
         max = max_temp_degC) |> 
  pivot_longer(cols = mean:min, names_to = "statistic", values_to = "value") |> 
  mutate(stream = "feather river",
         gage_agency = "CDEC",
         gage_number = "FRA",
         site_group = "feather river lfc")

feather_lfc_format %>% ggplot() + 
  geom_line(aes(x = date, y = value, color = statistic)) + 
  # geom_point(aes(x = date, y = mean_temp_degC), size = .001) +
  theme_minimal() 
```

#### Data from monitoring program

```{r}
feather_rst_hfc <- rst_enviro %>%
  filter(stream == "feather river", site == "herringer riffle", parameter == "temperature") %>%
  select(stream, date, value) %>%
  group_by(stream, date) |> 
  summarize(value = mean(value, na.rm = T)) |> 
  mutate(gage_agency = "DWR",
         gage_number = "logger",
         site_group = "feather river hfc",
         statistic = "mean",
         value = case_when(value < 0.5 ~ NA_real_,
                               T ~ value),
         value = as.numeric(value),
         value = na.approx(value, na.rm = F)) |> glimpse()

ggplot() +
  geom_line(data = feather_rst_hfc, aes(x = date, y = value)) +
  theme_minimal()

feather_rst_lfc <- rst_enviro %>%
  filter(stream == "feather river", site == "eye riffle", parameter == "temperature") %>%
  select(stream, date, value) %>%
  group_by(stream, date) |> 
  summarize(value = mean(value, na.rm = T)) |> 
  mutate(gage_agency = "DWR",
         gage_number = "logger",
         site_group = "feather river lfc",
         statistic = "mean",
         value = case_when(value < 0.5 ~ NA_real_,
                               T ~ value),
         value = as.numeric(value),
         value = na.approx(value, na.rm = F)) |> glimpse()

ggplot() +
  geom_line(data = feather_rst_lfc, aes(x = date, y = value)) +
  theme_minimal()
```

#### Combine data from gage and monitoring program

```{r}
feather_lfc_format_combined <- bind_rows(filter(feather_rst_lfc, year(date) < 2017), # rst, filter so it does not overlap with gage data
                        feather_lfc_format) %>% 
  group_by(stream, date, statistic, gage_agency, gage_number, site_group) |> 
  glimpse()
ggplot() +
  geom_line(data = feather_lfc_format_combined, aes(x = date, y = value, color = statistic)) +
  theme_minimal()

feather_hfc_format_combined <- bind_rows(filter(feather_rst_hfc, date > "2007-06-01"), # rst filter so does not overlap with gage data
                        feather_hfc_format) %>% 
  mutate(value = ifelse(is.nan(value) | is.infinite(value), NA, value)) |> 
  group_by(stream, date, statistic, gage_agency, gage_number, site_group) |> glimpse()
ggplot() +
  geom_line(data = feather_hfc_format_combined, aes(x = date, y = value, color = statistic)) +
  theme_minimal()
```

#### Fill in data gaps

Decided to build regression model between Butte Creek and Feather River data (using mean values)
We will use this model to predict values for min, mean, and max

```{r, include = F}

#-----Code to identify the date ranges for the gage v trap data
# LFC gage: 2018-present
# min(feather_lfc_format$date, na.rm = T)
# # LFC monitoring data: 1997-2006, 2017-2021 (not using 2017-2021 data, instead use gage)
# min(feather_rst_lfc$date)
# max(feather_rst_lfc$date)
# feather_rst_lfc |> 
#   filter(year(date) < 2016) |> 
#   summarize(max = max(date))
# 
# # HFC gage: 2003-2007
# min(feather_hfc_format$date, na.rm = T)
# max(feather_hfc_format$date, na.rm = T)
# # HFC monitoring data: 2008-2021 (not using data prior to 2008 so as not to overlap with gage data)
# feather_rst_hfc |> 
#   filter(year(date) > 2007) |> 
#   summarize(max = max(date),
#             min = min(date))

#------ Code to create dataframes that combine Feather data with Butte data for regression
# LFC
# create dataframe to use in regression
# This needs to be done for both mean, min, max

# need reformat the dataset so can find the dates when min/max are NA (e.g. otherwise just won't ahve data)
feather_lfc_format_wide <- feather_lfc_format_combined |> 
  ungroup() |> 
  select(-gage_agency, -gage_number) |> 
pivot_wider(id_cols = c(stream, date, site_group), names_from = "statistic", values_from = "value", values_fill = NA)

# Combine butte and feather together for regression modeling
feather_lfc_regression_data_full <- feather_lfc_format_wide |> 
  ungroup() |> 
  select(date, mean, max, min) |> 
  rename(feather_temp_mean = mean,
         feather_temp_min = min,
         feather_temp_max = max) |> 
  full_join(butte_format |> 
              select(date, mean_temp_degC, max_temp_degC, min_temp_degC) |> 
              rename(butte_temp_mean = mean_temp_degC,
                     butte_temp_min = min_temp_degC,
                     butte_temp_max = max_temp_degC))
# FOR PREDICTIONS identify gaps to predict data
feather_gap_mean <- feather_lfc_regression_data_full |> 
  filter(is.na(feather_temp_mean), !is.na(butte_temp_mean)) |> 
  select(-c(feather_temp_mean, feather_temp_min, feather_temp_max)) |> 
  rename(butte_temp = butte_temp_mean)
feather_gap_min <- feather_lfc_regression_data_full |> 
  filter(is.na(feather_temp_min), !is.na(butte_temp_min)) |> 
 select(-c(feather_temp_mean, feather_temp_min, feather_temp_max)) |> 
  rename(butte_temp = butte_temp_min)
feather_gap_max <- feather_lfc_regression_data_full |> 
  filter(is.na(feather_temp_max), !is.na(butte_temp_max)) |> 
 select(-c(feather_temp_mean, feather_temp_min, feather_temp_max)) |> 
  rename(butte_temp = butte_temp_max)

# FOR MODEL use data where there are no missing data for either butte or feather for regression modeling
feather_lfc_regression_data_mean <- feather_lfc_regression_data_full |> 
  filter(!is.na(feather_temp_mean), !is.na(butte_temp_mean)) |> 
  rename(butte_temp = butte_temp_mean,
         temp = feather_temp_mean)
feather_lfc_regression_data_min <- feather_lfc_regression_data_full |> 
  filter(!is.na(feather_temp_min), !is.na(butte_temp_min)) |> 
  rename(butte_temp = butte_temp_min,
         temp = feather_temp_min)
feather_lfc_regression_data_max <- feather_lfc_regression_data_full |> 
  filter(!is.na(feather_temp_max), !is.na(butte_temp_max)) |> 
  rename(butte_temp = butte_temp_max,
         temp = feather_temp_max)

# plot for mean
ggplot(data = feather_lfc_regression_data_mean, aes(x = butte_temp, y = temp)) +
  geom_point() +
  stat_smooth(method = "lm")
```

```{r, include = F}
# LFC regression and predictions

# MEAN Regression
split <-rsample::initial_split(feather_lfc_regression_data_mean, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
feather_lfc_mod_mean <- lm(temp ~ date + butte_temp, data = train)
summary(feather_lfc_mod_mean)
test_predict <- predict(feather_lfc_mod_mean, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)

# MIN Regression
split <-rsample::initial_split(feather_lfc_regression_data_min, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
feather_lfc_mod_min <- lm(temp ~ date + butte_temp, data = train)
summary(feather_lfc_mod_min)
test_predict <- predict(feather_lfc_mod_min, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)

# MAX Regression
split <-rsample::initial_split(feather_lfc_regression_data_max, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
feather_lfc_mod_max <- lm(temp ~ date + butte_temp, data = train)
summary(feather_lfc_mod_max)
test_predict <- predict(feather_lfc_mod_max, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)
```

```{r}
# Predictions
feather_gap_predicted_mean_lfc <- predict(feather_lfc_mod_mean, feather_gap_mean)
feather_lfc_mean_predicted <- feather_gap_mean |> 
  mutate(value = feather_gap_predicted_mean_lfc,
         statistic = "mean") |> 
  select(date, value, statistic)
ggplot(feather_lfc_mean_predicted, aes(x = date, y = value)) +
  geom_line()
feather_gap_predicted_min_lfc <- predict(feather_lfc_mod_min, feather_gap_min)
feather_lfc_min_predicted <- feather_gap_min |> 
  mutate(value = feather_gap_predicted_min_lfc,
         statistic = "min") |> 
  select(date, value, statistic)
ggplot(feather_lfc_min_predicted, aes(x = date, y = value)) +
  geom_line()
feather_gap_predicted_max_lfc <- predict(feather_lfc_mod_max, feather_gap_max)
feather_lfc_max_predicted <- feather_gap_max |> 
  mutate(value = feather_gap_predicted_max_lfc,
         statistic = "max") |> 
  select(date, value, statistic)
ggplot(feather_lfc_max_predicted, aes(x = date, y = value)) +
  geom_line()

feather_gap_lfc <- bind_rows(feather_lfc_max_predicted,
                             feather_lfc_mean_predicted,
                             feather_lfc_min_predicted) |> 
  mutate(stream = "feather river",
         site_group = "feather river lfc") %>% 
  pivot_wider(id_cols = c(date, stream, site_group), values_from = "value", names_from = "statistic") |>
  rename(mean_i = mean,
         max_i = max,
         min_i = min) |> 
  full_join(feather_lfc_format_combined |> 
              pivot_wider(id_cols = c(stream, date, gage_agency, gage_number, site_group), values_from = "value", names_from = "statistic")) |> 
  mutate(mean = ifelse(is.na(mean), mean_i, mean),
         min = ifelse(is.na(min), min_i, min),
         max = ifelse(is.na(max), max_i, max)) |> 
  select(-c(min_i, mean_i, max_i)) |> 
  pivot_longer(cols = mean:min, values_to = "value", names_to = "statistic") |> 
  group_by(stream, date, statistic, gage_agency, gage_number, site_group) |> 
  full_join(feather_lfc_sites) |> 
  glimpse()

ggplot() +
  geom_line(data = feather_gap_lfc, aes(x = date, y = value, color = statistic)) +
  theme_minimal()
```

```{r, include = F}
# need reformat the dataset so can find the dates when min/max are NA (e.g. otherwise just won't ahve data)
feather_hfc_format_wide <- feather_hfc_format_combined |> 
  ungroup() |> 
  select(-gage_agency, -gage_number) |> 
pivot_wider(id_cols = c(stream, date, site_group), names_from = "statistic", values_from = "value", values_fill = NA)
# set up dataframes for HFC
feather_hfc_regression_data_full <- feather_hfc_format_wide |> 
  ungroup() |> 
  select(date, mean, max, min) |> 
  rename(feather_temp_mean = mean,
         feather_temp_min = min,
         feather_temp_max = max) |> 
  full_join(butte_format |> 
              select(date, mean_temp_degC, max_temp_degC, min_temp_degC) |> 
              rename(butte_temp_mean = mean_temp_degC,
                     butte_temp_min = min_temp_degC,
                     butte_temp_max = max_temp_degC))
# identify gaps to predict data
feather_gap_mean <- feather_hfc_regression_data_full |> 
  filter(is.na(feather_temp_mean), !is.na(butte_temp_mean)) |> 
  select(-c(feather_temp_mean, feather_temp_min, feather_temp_max)) |> 
  rename(butte_temp = butte_temp_mean)
feather_gap_min <- feather_hfc_regression_data_full |> 
  filter(is.na(feather_temp_min), !is.na(butte_temp_min)) |> 
 select(-c(feather_temp_mean, feather_temp_min, feather_temp_max)) |> 
  rename(butte_temp = butte_temp_min)
feather_gap_max <- feather_hfc_regression_data_full |> 
  filter(is.na(feather_temp_max), !is.na(butte_temp_max)) |> 
 select(-c(feather_temp_mean, feather_temp_min, feather_temp_max)) |> 
  rename(butte_temp = butte_temp_max)

feather_hfc_regression_data_mean <- feather_hfc_regression_data_full |> 
  filter(!is.na(feather_temp_mean), !is.na(butte_temp_mean)) |> 
  rename(butte_temp = butte_temp_mean,
         temp = feather_temp_mean)
feather_hfc_regression_data_min <- feather_hfc_regression_data_full |> 
  filter(!is.na(feather_temp_min), !is.na(butte_temp_min)) |> 
  rename(butte_temp = butte_temp_min,
         temp = feather_temp_min)
feather_hfc_regression_data_max <- feather_hfc_regression_data_full |> 
  filter(!is.na(feather_temp_max), !is.na(butte_temp_max)) |> 
  rename(butte_temp = butte_temp_max,
         temp = feather_temp_max)

# plot for mean
ggplot(data = feather_hfc_regression_data_mean, aes(x = butte_temp, y = temp)) +
  geom_point() +
  stat_smooth(method = "lm")
```

```{r, include = F}
# HFC regression and predictions

# MEAN Regression
split <-rsample::initial_split(feather_hfc_regression_data_mean, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
feather_hfc_mod_mean <- lm(temp ~ date + butte_temp, data = train)
summary(feather_hfc_mod_mean)
test_predict <- predict(feather_hfc_mod_mean, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)

# MIN Regression
split <-rsample::initial_split(feather_hfc_regression_data_min, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
feather_hfc_mod_min <- lm(temp ~ date + butte_temp, data = train)
summary(feather_hfc_mod_min)
test_predict <- predict(feather_hfc_mod_min, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)

# MAX Regression
split <-rsample::initial_split(feather_hfc_regression_data_max, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
feather_hfc_mod_max <- lm(temp ~ date + butte_temp, data = train)
summary(feather_hfc_mod_max)
test_predict <- predict(feather_hfc_mod_max, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)
```

```{r}
# Predictions
feather_gap_predicted_mean_hfc <- predict(feather_hfc_mod_mean, feather_gap_mean)
feather_hfc_mean_predicted <- feather_gap_mean |> 
  mutate(value = feather_gap_predicted_mean_hfc,
         statistic = "mean") |> 
  select(date, value, statistic)
ggplot(feather_hfc_mean_predicted, aes(x = date, y = value)) +
  geom_line()
feather_gap_predicted_min_hfc <- predict(feather_hfc_mod_min, feather_gap_min)
feather_hfc_min_predicted <- feather_gap_min |> 
  mutate(value = feather_gap_predicted_min_hfc,
         statistic = "min") |> 
  select(date, value, statistic)
ggplot(feather_hfc_min_predicted, aes(x = date, y = value)) +
  geom_line()
feather_gap_predicted_max_hfc <- predict(feather_hfc_mod_max, feather_gap_max)
feather_hfc_max_predicted <- feather_gap_max |> 
  mutate(value = feather_gap_predicted_max_hfc,
         statistic = "max") |> 
  select(date, value, statistic)
ggplot(feather_hfc_max_predicted, aes(x = date, y = value)) +
  geom_line()

feather_gap_hfc <- bind_rows(feather_hfc_max_predicted,
                             feather_hfc_mean_predicted,
                             feather_hfc_min_predicted) |> 
  mutate(stream = "feather river",
         site_group = "feather river hfc") %>% 
  pivot_wider(id_cols = c(date, stream, site_group), values_from = "value", names_from = "statistic") |>
  rename(mean_i = mean,
         max_i = max,
         min_i = min) |> 
  full_join(feather_hfc_format_combined |> 
              pivot_wider(id_cols = c(stream, date, gage_agency, gage_number, site_group), values_from = "value", names_from = "statistic")) |> 
  mutate(mean = ifelse(is.na(mean), mean_i, mean),
         min = ifelse(is.na(min), min_i, min),
         max = ifelse(is.na(max), max_i, max)) |> 
  select(-c(min_i, mean_i, max_i)) |> 
  pivot_longer(cols = mean:min, values_to = "value", names_to = "statistic") |> 
  group_by(stream, date, statistic, gage_agency, gage_number, site_group) |> 
  distinct() |> 
  full_join(feather_hfc_sites) |> 
  glimpse()
ggplot() +
  geom_line(data = feather_gap_hfc, aes(x = date, y = value, color = statistic)) +
  theme_minimal()

```

## Mill Creek

-   Mill Creek temperature data is sourced from CDEC's site `MLM` from
    `1998-10-07` to `2022-07-13`

```{r}
# source CDEC - note that there are some missing data points
mill <- read_rds(here::here("data-raw", "standard-format-data-prep","temp_data", "mill_temp.rds")) |> glimpse()
mill_format <- mill %>%
  mutate(stream = "mill creek",
         site = stream, 
         subsite = site,
         gage_agency = "CDEC",
         gage_number = "MLM") 

summary(mill_format$date)

mill_format %>% ggplot() + 
  geom_line(aes(x = date, y = mean_temp_degC), color = "gray") + 
  # geom_point(aes(x = date, y = mean_temp_degC), size = .001) +
  theme_minimal()
```

## Sacramento

-   combined dataset spans `1998-10-01` to `2022-07-25` and includes RST
    environmental data from Knights Landing and USGS data from Wilkins

#### Gage Data

-   Data is from `USGS 11390500` and exists from `1998-10-01` to
    `2022-07-25` with a significant data gap between `1998-09-30` and
    `2016-10-01`
  - use for both Knights Landing and Tisdale

```{r}
WLK_USGS <- readRDS(here::here("data-raw", "standard-format-data-prep","temp_data", "sac_temp.rds")) |> glimpse()
sac_usgs_format <- WLK_USGS |> 
  rename(mean_temp_degC = temp_degC) |> 
  mutate(stream = "sacramento river",
         gage_agency = "USGS",
         gage_number = "11390500") 

# Plot
ggplot() +
  geom_line(data = sac_usgs_format, aes(x = date, y = mean_temp_degC), color = "black") +
  labs(x = "date",
       y = "Temperature (deg C)", 
       caption = "USGS 11390500")
```

#### Data from monitoring program

-   One site: `knights landing`; apply to Tisdale

-   Date range from `2002-10-04` to `2021-05-31` with a two year gap
    between `2016-06-20` and `2018-08-28`

```{r}
sac_rst_format <- rst_enviro %>% 
  filter(stream == "sacramento river", parameter == "temperature") %>% 
  select(stream, date, value) %>%
  rename(mean_temp_degC = value) %>%
  mutate(gage_agency = "CDFW",
         gage_number = "logger",
         mean_temp_degC = case_when(mean_temp_degC < 0.5 ~ NA_real_,
                               T ~ mean_temp_degC),
         mean_temp_degC = as.numeric(mean_temp_degC),
         mean_temp_degC = na.approx(mean_temp_degC, na.rm = F)) |> glimpse()

summary(sac_rst_format$date)

ggplot() +
  geom_line(data = sac_rst_format, aes(x = date, y = mean_temp_degC))

```

#### Combine Sacramento data

-   combined dataset spans `1998-10-01` to `2022-07-25` and includes RST
    environmental data from Knights Landing and USGS data from Wilkins

```{r}

sac_format <- bind_rows(sac_rst_format, # rst
                        sac_usgs_format) %>% 
  group_by(stream, date, mean_temp_degC, gage_agency, gage_number) |> 
  distinct()
# need to apply values for all sacramento sites and subsites
sac_sites <- catch |> 
  filter(stream == "sacramento river", site %in% c("knights landing", "tisdale")) |> 
  distinct(stream, site, subsite)

sac_format_all <- full_join(sac_format, sac_sites)

summary(sac_format_all$date)

ggplot() +
  geom_line(data = sac_format_all, aes(x = date, y = mean_temp_degC, color = site)) 
  #facet_wrap(~site)

```

## Yuba

- YR7 CDEC gage is used, however, this only contains data from 2020 onwards. Temperature data collected along with RST data is used to fill the gap prior to 2020. 
- In order to fill remaining data gaps a linear regression model was built to determine the relationship between Yuba River temperature Butte Creek temperature (Butte Creek temperature is an extensive dataset). This model was then used to predict temperatures for dates where there were data gaps.

#### Gage data

```{r}
YR7_daily_temps <- readRDS(here::here("data-raw", "standard-format-data-prep","temp_data", "yuba_temp.rds"))

yuba_format <- YR7_daily_temps %>%
  mutate(stream = "yuba river",
         gage_agency = "CDEC",
         gage_number = "YR7")

yuba_sites <- filter(catch, stream == "yuba river") |> 
  select(stream, site, subsite) |> 
  distinct()

yuba_format %>% ggplot() + 
  geom_line(aes(x = date, y = mean_temp_degC)) + 
  # geom_point(aes(x = date, y = mean_temp_degC), size = .001) +
  theme_minimal() 

```
#### Monitoing program data

```{r}

yuba_rst_format <- rst_enviro %>% 
  filter(stream == "yuba river", parameter == "temperature") %>% 
  select(stream, site, subsite, date, value) %>%
  group_by(stream, date) |> 
  summarize(value = mean(value)) |> 
  rename(mean_temp_degC = value) %>%
  mutate(gage_agency = "DWR",
         gage_number = "logger") %>%
  glimpse

summary(yuba_rst_format$date)

ggplot() +
  geom_line(data = yuba_rst_format, aes(x = date, y = mean_temp_degC))
```

#### Combine Yuba gage and logger data

```{r}
yuba_combined <- bind_rows(yuba_format, yuba_rst_format)

ggplot() +
  geom_line(data = yuba_combined, aes(x = date, y = mean_temp_degC)) 
```

#### Fill in data gaps

```{r}
# combine butte and yuba together for regression modeling
yuba_regression_data_full <- yuba_combined |> 
  ungroup() |> 
  select(date, mean_temp_degC, max_temp_degC, min_temp_degC) |> 
  rename(yuba_temp_mean = mean_temp_degC,
         yuba_temp_min = min_temp_degC,
         yuba_temp_max = max_temp_degC) |> 
  full_join(butte_format |> 
              select(date, mean_temp_degC, max_temp_degC, min_temp_degC) |> 
              rename(butte_temp_mean = mean_temp_degC,
                     butte_temp_min = min_temp_degC,
                     butte_temp_max = max_temp_degC))
# FOR PREDICTIONS identify gaps to predict data
yuba_gap_mean <- yuba_regression_data_full |> 
  filter(is.na(yuba_temp_mean), !is.na(butte_temp_mean)) |> 
  select(-c(yuba_temp_mean, yuba_temp_min, yuba_temp_max)) |> 
  rename(butte_temp = butte_temp_mean)
yuba_gap_min <- yuba_regression_data_full |> 
  filter(is.na(yuba_temp_min), !is.na(butte_temp_min)) |> 
 select(-c(yuba_temp_mean, yuba_temp_min, yuba_temp_max)) |> 
  rename(butte_temp = butte_temp_min)
yuba_gap_max <- yuba_regression_data_full |> 
  filter(is.na(yuba_temp_max), !is.na(butte_temp_max)) |> 
select(-c(yuba_temp_mean, yuba_temp_min, yuba_temp_max)) |> 
  rename(butte_temp = butte_temp_max)

# FOR MODEL use data where there are no missing data for either butte or feather for regression modeling
yuba_regression_data_mean <- yuba_regression_data_full |> 
  filter(!is.na(yuba_temp_mean), !is.na(butte_temp_mean)) |> 
  rename(butte_temp = butte_temp_mean,
         temp = yuba_temp_mean)
yuba_regression_data_min <- yuba_regression_data_full |> 
  filter(!is.na(yuba_temp_min), !is.na(butte_temp_min)) |> 
  rename(butte_temp = butte_temp_min,
         temp = yuba_temp_min)
yuba_regression_data_max <- yuba_regression_data_full |> 
  filter(!is.na(yuba_temp_max), !is.na(butte_temp_max)) |> 
  rename(butte_temp = butte_temp_max,
         temp = yuba_temp_max)
# plot for mean
ggplot(data = yuba_regression_data_mean, aes(x = butte_temp, y = temp)) +
  geom_point() +
  stat_smooth(method = "lm")
```

```{r, include = F}

# MEAN Regression
split <-rsample::initial_split(yuba_regression_data_mean, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
yuba_mod_mean <- lm(temp ~ date + butte_temp, data = train)
summary(yuba_mod_mean)
test_predict <- predict(yuba_mod_mean, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)

# MIN Regression
split <-rsample::initial_split(yuba_regression_data_min, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
yuba_mod_min <- lm(temp ~ date + butte_temp, data = train)
summary(yuba_mod_min)
test_predict <- predict(yuba_mod_min, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)

# MAX Regression
split <-rsample::initial_split(yuba_regression_data_max, prop = 0.8)
train <- rsample::training(split)
test <- rsample::testing(split)
yuba_mod_max <- lm(temp ~ date + butte_temp, data = train)
summary(yuba_mod_max)
test_predict <- predict(yuba_mod_max, test)
test_predict_df <- test |>
  mutate(predicted = test_predict)
# evaluate predictions - MAPE of 10% is not bad
mean(abs((
  test_predict_df$predicted - test_predict_df$temp
)) / test_predict_df$temp)
```

```{r}
# Predictions
yuba_gap_predicted_mean <- predict(yuba_mod_mean, yuba_gap_mean)
yuba_mean_predicted <- yuba_gap_mean |> 
  mutate(value = yuba_gap_predicted_mean,
         statistic = "mean") |> 
  select(date, value, statistic)
ggplot(yuba_mean_predicted, aes(x = date, y = value)) +
  geom_line()
yuba_gap_predicted_min <- predict(yuba_mod_min, yuba_gap_min)
yuba_min_predicted <- yuba_gap_min |> 
  mutate(value = yuba_gap_predicted_min,
         statistic = "min") |> 
  select(date, value, statistic)
ggplot(yuba_min_predicted, aes(x = date, y = value)) +
  geom_line()
yuba_gap_predicted_max <- predict(yuba_mod_max, yuba_gap_max)
yuba_max_predicted <- yuba_gap_max |> 
  mutate(value = yuba_gap_predicted_max,
         statistic = "max") |> 
  select(date, value, statistic)
ggplot(yuba_max_predicted, aes(x = date, y = value)) +
  geom_line()

yuba_gap <- bind_rows(yuba_max_predicted,
                      yuba_mean_predicted,
                      yuba_min_predicted) |> 
  mutate(stream = "yuba river") |> 
  pivot_wider(id_cols = c(date, stream), values_from = "value", names_from = "statistic") |> 
  full_join(yuba_combined) |> 
  mutate(mean_temp_degC = ifelse(is.na(mean_temp_degC), mean, mean_temp_degC),
         min_temp_degC = ifelse(is.na(min_temp_degC), min, min_temp_degC),
         max_temp_degC = ifelse(is.na(max_temp_degC), max, max_temp_degC)) |> 
  select(-c(mean, max, min)) |> 
    rename(mean = mean_temp_degC,
           min = min_temp_degC,
           max = max_temp_degC) |> 
    pivot_longer(cols = mean:min, values_to = "value", names_to = "statistic") |>
  group_by(stream, date, statistic, gage_agency, gage_number) |> 
  full_join(yuba_sites) |> 
  glimpse()

ggplot() +
  geom_line(data = yuba_gap, aes(x = date, y = value, color = statistic)) +
  theme_minimal()
```
# Combine temperature data {.tabset}

```{r}
combined_temp <- bind_rows(battle_format,
                           butte_format_all,
                           clear_format,
                           deer_format,
                           mill_format,
                           sac_format_all
                           ) %>%
  rename(mean  = mean_temp_degC,
         max = max_temp_degC,
         min = min_temp_degC) %>%
  pivot_longer(cols = c(mean, max, min), names_to = "statistic", values_to = "value") |> 
  bind_rows(feather_gap_hfc,
            feather_gap_lfc,
            yuba_gap) |> 
  glimpse()
```

## QA/QC

```{r}
summary(combined_temp)
unique(combined_temp$stream)
unique(combined_temp$site)
unique(combined_temp$subsite)
ggplot(filter(combined_temp, statistic == "mean"), aes(x = date, y = value, color = site)) +
  theme_minimal() +
  geom_line() +
  facet_wrap(~stream)
# TODO look into the NA dates for Butte Creek
filter(combined_temp, is.na(date)) 
# TODO look into the NAs and Infs
filter(combined_temp, statistic == "mean", value == "NaN") 
filter(combined_temp, statistic == "max", value  == "-Inf") 

combined_temp_clean <- filter(combined_temp, !is.na(date)) %>% 
  mutate(value = ifelse(is.nan(value), NA, value),
         value = ifelse(value == "-Inf", NA, value)) %>% glimpse()

summary(combined_temp_clean)

filter(combined_temp_clean, value == "NaN") 
filter(combined_temp_clean, value == "-Inf") 
unique(combined_temp_clean$stream)
unique(combined_temp_clean$source)
```

```{r, include = FALSE}
f <- function(input, output) write_csv(input, file = output)

gcs_upload(combined_temp_clean,
           object_function = f,
           type = "csv",
           name = "standard-format-data/standard_temperature.csv",
           predefinedAcl = "bucketLevel")
write_csv(combined_temp_clean, "data/standard-format-data/standard_temperature.csv")
```
